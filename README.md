# The Advanced Random Number Generator with Intel Edison

## Overview
For any programming, when we need to use a random number, we use 'rand' function that is commonly provided by default. We often _do believe_ that a number generated by random functions is a true random number (at least I did until I faced the truth). Sadly, that is not true.

## Background
A random number generator is essentially under the category of _Deterministic Finite Automaton_ (or simply say DFA). You could learn more about DFA or further stuff on the [Wikipedia](https://en.wikipedia.org/wiki/Deterministic_finite_automaton), but it is out of the scope of this work. The only thing we need to know is the most random functions generate _pseudoramdon number_ and the numbers generated can be predictable if we know what type of generator and input used! However, in reality, computer scientists invented awesome algorithms that makes pseudorandom numbers are almost impossible to predict in practice. Here is some algorithms for pseudorandom numbers has pretty good performance.

### Linear Congruential Generator
This is one of the common pseudorandom number generator. This is fast and lightweight. It requires minimal memory, but it also has some weakness like cryptographic issue. For more information, here is [Wikipedia link](https://en.wikipedia.org/wiki/Linear_congruential_generator) might be helpful.

In this project, we are going to use this method because it is pretty intuitive and easy to implement.
However, there are many pseudorandom number generator has better performance and secure (like cryptographic pseudorandom number generator!), and of course, you can try different method whatever you want.

The method can be described as a closed-form expression like:

![equation](https://latex.codecogs.com/gif.latex?\fn_cm&space;X_{n&plus;1}=(aX_n&plus;c)\mod{m})

where a, c, and m are constant number satisfies the following conditions
>m > 0\
>0 < a < m\
>0 <= c < m


the seed number ![equation](https://latex.codecogs.com/gif.latex?\fn_phv&space;X_0) should be a non-zero natural number and smaller than m

In LCG, it is really important to pick a good number for those constants to have a maximum period length. As your period length gets longer, the numbers generated are more safe from the prediction. 
You can calculate the best combinations for practice, 
but in this practice, we will pick some small _prime_ numbers so we can see the cycle of numbers generated
>m = 55\
>a = 7\
>c = 3


So now we get everything we need for developing the LCG, and here is the sample code that outputs random numbers to check if it is working nicely.
```python
import time

class LCG():
    m = 55
    a = 7
    c = 3

    def __init__(self, seed):
        self.prev = seed
        
    def rand(self):
        self.prev = (self.a*self.prev+self.c)%self.m
        return self.prev 

testing = LCG(2)
while(1):
    print testing.rand()
    time.sleep(1)
```

And when you run this code, you will see the algorithm is repeatedly generating sequence of numbers:

>17 12 32 7 52 37 42 22 47 2 ...

## The Advanced Random Number Generator
As we discussed above, the LCG has limitation that the numbers can be predictable. Technically, if you have a good computer (like supercomputer!), sequence of the generated numbers, and an appropriate algorithm, you can find the seed number. This is not only LCG's limitation but all of pseudorandom number generators. Some might be harder to predict (or almost impossible with the current technology), but theoretically, every pseudorandom numbers can be predictable.\
Then is it really impossible to make a true random number? Well, if we define the randomness is the one that cannot be predictable, it is actually possible to generate a true random number!

### Noise
The noise is pretty common stuff. When you're listening music, changing radio station, or speaking over the phone, you could hear the noise. Noise is somewhat unpredictable. The idea starts from here; if we can use those noise for the random numbers, the numbers generated will be unpredictable, too.\
As long as you are able to get those noise, you can make true random numbers by your own, and that is why we're going to use Intel Edison.

### Intel Edison
The Intel Edison is a single board computer (SBC) announced in 2014. With the breakout board, you can use various modules and sensors with powerful cpu for a SBC.
I will use this to measure a noise with sensors. However, if you don't have Edison but other SBCs like raspberry pi or Alduino, it is welcome to use it.
I believe using raspberry pi would be easier and more intuitive, but I use Edison because I don't have micro-sd card on my raspberry pi right now :D

#### Preperation
For anyone who uses the Intel Edison for the first time, here is [user guide](https://software.intel.com/en-us/intel-edison-board-user-guide) might be helpful.
	* [Instruction](https://software.intel.com/en-us/assembling-intel-edison-board-with-arduino-expansion-board) for assembling
	* [Instruction](https://software.intel.com/en-us/setting-up-serial-terminal-intel-edison-board) for communicating with the device via USB terminal

### Modules
For this project, we are going to use 3 sensor modules: Light, Sound, and Temperature modules.
You do not need to use exactly same modules what I'm using. I'm using those because I only have three, so if you have another module or just have one of them, that is totally fine.

### MRAA
MRAA is the low level skeleton library for communication on GNU/Linux platforms. For more information, [this link](https://github.com/intel-iot-devkit/mraa) would be helpful. The reason we are going to use this library is to communicate with modules. To check if the library is working, we are going to create _Hello Mraa_ c file:

```c
#include "mraa.h"

int main(int argc, char** argv){
	const char* board_name = mraa_get_platform_name();
	fprintf(stdout, "hello mraa\n Version: %s\n Running on %s\n", mraa_get_version(), board_name);
	mraa_deinit();

	return MRAA_SUCCESS;
}
```

We have to compile to create an executable file first.\
suppose we have c file named _hello.c_, then

> gcc -o hello hello.c -lmraa

would generate _hello_ file.

If the compiler cannot recognize functions, then you might want to update mraa library.

#### Update MRAA
For some reason, if you are unable to compile, then try updating mraa library.

> echo "src mraa-upm http://iotdk.intel.com/repos/3.5/intelgalactic/opkg/i586" > /etc/opkg/mraa-upm.conf
> opkg update
> opkg install mraa

### Using Sensor Modules
Once you have mraa, receiving data from the sensor is a piece of cake. Initialize, read, and print. Done. For those who want to check if the sensors are working, here is a sample code that reads data from sensors:

```c
#include "mraa.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <math.h>

//referenced from the 'Grove Temperature Sensor'
const int B = 4275;               // B value of the thermistor
const int R0 = 100000;            // R0 = 100k

unsigned int wait=1000; // used for the sound sensor 

// declare the analog input contexts
mraa_aio_context temp;
mraa_aio_context light;
mraa_aio_context sound;

// initialize the contexts
void init(void){
	// aio means analog, and you must plug temperature sensor on AIO0, light sensor on AIO1, and sound sensor on AIO2
	temp = mraa_aio_init(0); // AIO0
	light = mraa_aio_init(1); // AIO1
	sound = mraa_aio_init(2); // AIO2
}

void measureSensors(void){
	// if the sensors are not initialized, exit with 1
	if(temp==NULL||light==NULL||sound==NULL){
			fprintf(stderr,"unable to initialize AIO");
		exit(1);
	}
	char buf[50];
	uint16_t temp_val;
	uint16_t light_val;
	uint16_t sound_val;
	float R;
	float temperature;
	float adj_temp;
	float adj_light;
	float adj_sound;
	int n;
	int index;
	while(1){
		adj_sound = 0;
		adj_temp = 0;
		adj_light = 0;
		// mreasuring data from sensors and finding average value
		for(index=0;index<1000000;index+=wait){
			//measuring analog data
			sound_val = mraa_aio_read(sound);
			temp_val = mraa_aio_read(temp);
			light_val = mraa_aio_read(light);
			//recording sound
			adj_sound += sound_val;
			//recording temperature
			R = R0*(1023.0/temp_val-1.0);
			adj_temp += 1.0/(log(R/R0)/B+1/298.15)-273.15;
			//recording light
			adj_light += light_val;
			usleep(wait);
		}
    adj_temp = adj_temp/(1000000/wait);
		adj_light = adj_light/(1000000/wait);
		adj_sound = adj_sound/(1000000/wait);
		sprintf(buf, "temp:%.1f\tlight:%.1f\tsound:%.1f\n",adj_temp,adj_light,adj_sound);
		n = strlen(buf);
		write(1,buf,n);
	}
}

int main(int argv, char **argc){
	init();
	measureSensors();
}
```

Once you compile and run the code, you might see outputs like:
>temp:23.1	light:700.3	sound:103.6
and that is somewhat measurable noises we want to get

### Generate Random numbers using Sensors
Now, we have everything we need to build the _Advanced Random Number Generator_. What we want to do is using noises and use it to make a _noise_ on the generator. Recall the LCG we used above:

> output = (a\*input+c)%m\
> where a=5, c=1, m=10

The LCG we tested with a seed number=2, it repeatedly generates a sequence of 10 numbers. Now, we are going to create some noise on the same algorithm and make a remarkable result.\
Here is the sample code that creates noised-random-numbers:

```c
#include "mraa.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <math.h>

//referenced from the 'Grove Temperature Sensor'
const int B = 4275;               // B value of the thermistor
const int R0 = 100000;            // R0 = 100k

unsigned int wait=1000; // wait 1000 microseconds after the measurement
unsigned int period = 1000000; // every 1 second, outputs the data

const unsigned short M = 55;
const unsigned short A = 7;
const unsigned short C = 3;

// declare the analog input contexts
mraa_aio_context temp;
mraa_aio_context light;
mraa_aio_context sound;

// initialize the contexts
int init(int argv, char **argc){
	// aio means analog, and you must plug temperature sensor on AIO0, light sensor on AIO1, and sound sensor on AIO2
	temp = mraa_aio_init(0); // AIO0
	light = mraa_aio_init(1); // AIO1
	sound = mraa_aio_init(2); // AIO2
	if(argv>2){
		fprintf(stderr, "too many arguments.\n\tUsage: lcg <seed number>\n");
		exit(1);
	}else if(argv<2){
		fprintf(stderr, "seed number must be provided.\n\tUsage: lcg <seed number>\n");
		exit(1);
	}else{
		int seed = atoi(argc[1]);
		if(seed==0||seed>=M){
			fprintf(stderr, "invalid number. number must be an integer smaller than %d.\n\tUsage: lcg <seed number>\n",M);
			exit(1);
		}
		return seed;
	}

}

void measureSensors(int seed){
	// if the sensors are not initialized, exit with 1
	if(temp==NULL||light==NULL||sound==NULL){
		fprintf(stderr,"unable to initialize AIO");
		exit(1);
	}
	char buf[50];
	uint16_t temp_val;
	uint16_t light_val;
	uint16_t sound_val;
	float R;
	float temperature;
	float adj_temp;
	float adj_light;
	float adj_sound;
	int n;
	int index;
	int frequency = period/wait;
	int prev = seed;
	while(1){
		adj_sound = 0;
		adj_temp = 0;
		adj_light = 0;
		// mreasuring data from sensors and finding average value
		for(index=0;index<period;index+=wait){
			//measuring analog data
			sound_val = mraa_aio_read(sound);
			temp_val = mraa_aio_read(temp);
			light_val = mraa_aio_read(light);
			//recording sound
			adj_sound += sound_val;
			//recording temperature
			R = R0*(1023.0/temp_val-1.0);
			adj_temp += 1.0/(log(R/R0)/B+1/298.15)-273.15;
			//recording light
			adj_light += light_val;
			usleep(wait);
		}
    adj_temp = adj_temp/frequency;
		adj_light = adj_light/frequency;
		adj_sound = adj_sound/frequency;
		unsigned long noise = (adj_temp*adj_light*adj_sound);
		int rand = prev+noise;
		rand = (A*rand+C)%M;
		// Random# is a noised random number generated by the algorithm we used for LCG.
		// Noise is the multiplication of three noises.
		sprintf(buf, "Random#: %d\tNoise: %d\n",rand,noise);
		n = strlen(buf);
		write(1,buf,n);
		prev = rand;
	}
}

int main(int argv, char **argc){
	int seed = init(argv,argc);
	measureSensors(seed);
}
```

Because I don't want to make it too complicated, I basically multiplied 3 noise values. 
If you want to have a large range of noise, you can use different methods like take an exponential value using two noises. 
All I did in that code is basically use an addition of previous random number + noise as a seed number, and because the noise is pretty random, we will never get the same number even if we all use same initial seed number.

### Overall
In the first experiment, we could see the limitation of the pseudorandom number generator. Although I weakened the algorithm and use the specific seed number for the test purpose, that vulnerability is still applicable to the well-developed and secured pseudorandom number generators.\
The second experiment is adding some noise and making it is really unpredictable (maybe you can if you have a superpower like THANOS :D). That is not hard to implement but shows incredible performance.

## Beyond the scope of the book
Isn't interesting to see you can actually make your own random number is really powerful? If you are fascinated with this idea or want to use this idea to your project or anything, there is a great website that you may like to see.\
[Random.org](https://www.random.org) is the website that presents a true randomness using same idea we discussed. This idea is also inspired by this website.

## References
* [Intel Edison](https://software.intel.com/en-us/intel-edison-board-user-guide)(https://software.intel.com/en-us/intel-edison-board-user-guide)
* [Updating MRAA on Edison](https://upm.mraa.io/Documentation/mraa.html)(https://upm.mraa.io/Documentation/mraa.html)
* [Random.org](http://www.random.org)(http://www.random.org)
* [LCG Wikipedia link](https://en.wikipedia.org/wiki/Linear_congruential_generator)(https://en.wikipedia.org/wiki/Linear_congruential_generator)
